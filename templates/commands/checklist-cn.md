--- 
description: 根据用户需求为当前功能生成自定义检查表。
scripts:
  sh: scripts/bash/check-prerequisites.sh --json
  ps: scripts/powershell/check-prerequisites.ps1 -Json
---

## 检查表目的：“英文单元测试”

**核心概念**：检查表是**需求编写的单元测试** —— 它们验证特定领域内需求的质量、清晰度和完整性。

**不用于验证/测试：**

- ❌ 不是“验证按钮是否点击正确”
- ❌ 不是“测试错误处理是否工作”
- ❌ 不是“确认 API 返回 200”
- ❌ 不是检查代码/实现是否符合规格说明

**用于需求质量验证：**

- ✅ “是否为所有卡片类型定义了视觉层级需求？”（完整性）
- ✅ “‘突出显示’是否通过具体的尺寸/位置进行了量化？”（清晰度）
- ✅ “所有交互元素的悬停状态需求是否是否一致？”（一致性）
- ✅ “是否为键盘导航定义了无障碍需求？”（覆盖率）
- ✅ “规格说明是否定义了 Logo 图片加载失败时的处理方式？”（边界情况）

**比喻**：如果您的规格说明是用英文编写的代码，那么检查表就是它的单元测试套件。您正在测试需求是否编写良好、完整、无歧义且已准备好实施 —— 而不是测试实现是否工作。

## 用户输入

```text
$ARGUMENTS
```

在继续之前，您**必须**考虑用户输入（如果不为空）。

## 执行步骤

1. **设置**：从仓库根目录运行 `{SCRIPT}`，并解析 FEATURE_DIR 和 AVAILABLE_DOCS 列表的 JSON。
   - 所有文件路径必须是绝对路径。
   - 对于参数中包含单引号的情况（如 "I'm Groot"），请使用转义语法：例如 'I'\''m Groot'（或者尽可能使用双引号:"I'm Groot"）。

2. **澄清意图（动态）**：推导出最多三个初始的上下文澄清问题（不使用预设目录）。这些问题必须：
   - 根据用户的表述 + 从规格说明/计划/任务中提取的信号生成
   - 仅针对会对检查表内容产生实质性影响的信息提问
   - 如果在 `$ARGUMENTS` 中已经明确，则单独跳过
   - 宁缺毋滥，追求精准而非广度

   生成算法：
   1. 提取信号：功能领域关键词（例如：auth, latency, UX, API）、风险指标（“关键”、“必须”、“合规”）、利益相关者提示（“QA”、“评审”、“安全团队”）以及明确的交付物（“a11y”、“回滚”、“契约”）。
   2. 将信号聚类为候选关注领域（最多 4 个），按相关性排序。
   3. 如果不明确，识别可能的受众和时机（作者、评审者、QA、发布）。
   4. 检测缺失的维度：范围广度、深度/严谨性、风险重点、排除边界、可衡量的验收标准。
   5. 从这些原型中制定问题：
      - 范围精炼（例如，“这应该包括与 X 和 Y 的集成触点，还是仅限于本地模块的正确性？”）
      - 风险优先级（例如，“这些潜在风险领域中的哪些应该接受强制性的门禁检查？”）
      - 深度校准（例如，“这是一个轻量级的预提交检查列表，还是一个正式的发布门禁？”）
      - 受众定位（例如，“这将仅由作者使用，还是在 PR 评审期间由同行使用？”）
      - 边界排除（例如，“我们这轮是否应该明确排除性能调优项？”）
      - 场景类别缺失（例如，“未检测到恢复流程 —— 回滚/部分失败路径是否在范围内？”）

   问题格式规则：
   - 如果提供选项，生成一个紧凑的表格，包含列：选项 | 候选项 | 为什么重要
   - 最多限制 A–E 选项；如果自由格式回答更清晰，则省略表格
   - 绝不要要求用户重复他们已经说过的话
   - 避免推测性类别（不幻想）。如果不确定，请明确询问：“请确认 X 是否属于范围内。”

   无法交互时的默认设置：
   - 深度：标准
   - 受众：如果是代码相关的，则为评审者 (PR)；否则为作者
   - 重点：前 2 个相关聚类

   输出问题（标记 Q1/Q2/Q3）。回答后：如果 ≥2 个场景类别（替代 / 异常 / 恢复 / 非功能领域）仍不明确，您可以追加最多两个有针对性的跟进问题（Q4/Q5），每个问题附带一行理由（例如，“恢复路径风险未解决”）。总共不要超过五个问题。如果用户明确拒绝更多，则停止追问。

3. **理解用户请求**：结合 `$ARGUMENTS` + 澄清回答：
   - 推导检查表主题（例如：安全、评审、部署、UX）
   - 整合用户提到的明确必需项
   - 将选定的重点映射到类别框架
   - 从规格说明/计划/任务中推断任何缺失的上下文（不要幻想）

4. **加载功能上下文**：从 FEATURE_DIR 读取：
   - spec.md：功能需求和范围
   - plan.md（如果存在）：技术细节、依赖关系
   - tasks.md（如果存在）：实现任务

   **上下文加载策略**：
   - 仅加载与活跃关注领域相关的必要部分（避免转储全文件）
   - 优先将长章节总结为简明扼要的场景/需求要点
   - 使用渐进式披露：仅在检测到缺口时添加后续检索
   - 如果源文档很大，生成临时摘要项而不是嵌入原始文本

5. **生成检查表** —— 创建“需求单元测试”：
   - 如果 `FEATURE_DIR/checklists/` 目录不存在，则创建它
   - 生成唯一的检查表文件名：
     - 根据领域使用简短、描述性的名称（例如 `ux.md`, `api.md`, `security.md`）
     - 格式：`[domain].md`
     - 如果文件已存在，则追加到现有文件
   - 按顺序编号，从 CHK001 开始
   - 每次运行 `/speckit.checklist` 都会创建一个新文件（绝不覆盖现有检查表）

   **核心原则 —— 测试需求，而非实现**：
   每个检查项必须从以下方面评估**需求本身**：
   - **完整性**：是否所有必要的需求都已具备？
   - **清晰度**：需求是否明确且具体？
   - **一致性**：需求之间是否相互协调？
   - **可衡量性**：需求是否可以被客观验证？
   - **覆盖率**：是否涵盖了所有场景/边界情况？

   **类别结构** —— 按需求质量维度对项目进行分组：
   - **需求完整性**（所有必要的需求都记录了吗？）
   - **需求清晰度**（需求是否具体且无歧义？）
   - **需求一致性**（需求是否对齐且无冲突？）
   - **验收标准质量**（成功标准是否可衡量？）
   - **场景覆盖率**（是否涵盖了所有流程/案例？）
   - **边界情况覆盖率**（是否定义了边界条件？）
   - **非功能需求**（性能、安全、无障碍等 —— 它们是否被指定？）
   - **依赖关系与假设**（它们是否被记录并验证？）
   - **歧义与冲突**（哪些内容需要澄清？）

   **如何编写检查项 —— “英文单元测试”**：

   ❌ **错误示例**（测试实现）：
   - “验证落地页显示 3 个剧集卡片”
   - “在桌面上测试悬停状态是否工作”
   - “确认点击 Logo 会导航到首页”

   ✅ **正确示例**（测试需求质量）：
   - “是否指定了精选剧集的准确数量和布局？” [完整性]
   - “‘突出显示’是否通过具体的尺寸/位置进行了量化？” [清晰度]
   - “所有交互元素的悬停状态需求是否一致？” [一致性]
   - “是否为所有交互式 UI 定义了键盘导航需求？” [覆盖率]
   - “规格说明是否定义了 Logo 图片加载失败时的回退行为？” [边界情况]
   - “是否为异步剧集数据定义了加载状态？” [完整性]
   - “规格说明是否为竞争的 UI 元素定义了视觉层级？” [清晰度]

   **项目结构**：
   每个项目应遵循此模式：
   - 以提问格式询问需求质量
   - 关注规格说明/计划中“所写的”（或未写的）内容
   - 在括号中包含质量维度 [完整性/清晰度/一致性等]
   - 在检查现有需求时引用规格说明章节 `[Spec §X.Y]`
   - 在检查缺失需求时使用 `[Gap]` 标记

   **按质量维度分类的示例**：

   完整性：
   - “是否为所有 API 失败模式定义了错误处理需求？ [Gap]”
   - “是否为所有交互元素指定了无障碍需求？ [完整性]”
   - “是否为响应式布局定义了移动端断点需求？ [Gap]”

   清晰度：
   - “‘快速加载’是否通过具体的时间阈值进行了量化？ [清晰度, Spec §NFR-2]”
   - “是否明确定义了‘相关剧集’的选择标准？ [清晰度, Spec §FR-5]”
   - “‘突出’是否通过可衡量的视觉属性进行了定义？ [歧义, Spec §FR-4]”

   一致性：
   - “导航需求是否在所有页面上保持对齐？ [一致性, Spec §FR-10]”
   - “卡片组件的需求在落地页和详情页之间是否一致？ [一致性]”

   覆盖率：
   - “是否为零数据场景（无剧集）定义了需求？ [覆盖率, 边界情况]”
   - “是否涵盖了并发用户交互场景？ [覆盖率, Gap]”
   - “是否为部分数据加载失败指定了需求？ [覆盖率, 异常流程]”

   可衡量性：
   - “视觉层级需求是否可衡量/可测试？ [验收标准, Spec §FR-1]”
   - “‘平衡的视觉权重’是否可以被客观验证？ [可衡量性, Spec §FR-2]”

   **场景分类与覆盖率**（需求质量关注点）：
   - 检查是否存在以下需求：主要、替代、异常/错误、恢复、非功能场景
   - 对于每个场景类别，提问：“[场景类型] 需求是否完整、清晰且一致？”
   - 如果缺失场景类别：“[场景类型] 需求是故意排除的还是遗漏的？ [Gap]”
   - 当发生状态变更时，包含恢复力/回滚：“是否为迁移失败定义了回滚需求？ [Gap]”

   **可追溯性要求**：
   - 最低要求：≥80% 的项目必须包含至少一个可追溯性引用
   - 每个项目应引用：规格说明章节 `[Spec §X.Y]`，或使用标记：`[Gap]`, `[歧义]`, `[冲突]`, `[假设]`
   - 如果没有 ID 系统：“是否建立了需求与验收标准的 ID 方案？ [可追溯性]”

   **发现并解决问题**（需求质量问题）：
   就需求本身提出问题：
   - 歧义：“‘快速’一词是否通过具体的指标进行了量化？ [歧义, Spec §NFR-1]”
   - 冲突：“§FR-10 和 §FR-10a 之间的导航需求是否存在冲突？ [冲突]”
   - 假设：“‘播客 API 始终可用’的假设是否经过验证？ [假设]”
   - 依赖关系：“是否记录了外部播客 API 的需求？ [依赖关系, Gap]”
   - 缺失定义：“‘视觉层级’是否通过可衡量的标准进行了定义？ [Gap]”

   **内容整合**：
   - 软上限：如果原始候选项目 > 40 个，按风险/影响进行排序
   - 合并检查同一需求方面的近乎重复的项目
   - 如果 >5 个低影响边界情况，创建一个项目：“需求中是否涵盖了边界情况 X, Y, Z？ [覆盖率]”

   **🚫 绝对禁止** —— 这些会使其变成实现测试，而不是需求测试：
   - ❌ 任何以“验证”、“测试”、“确认”、“检查”+ 实现行为开头的项目
   - ❌ 引用代码执行、用户操作、系统行为
   - ❌ “显示正确”、“运行正常”、“功能符合预期”
   - ❌ “点击”、“导航”、“渲染”、“加载”、“执行”
   - ❌ 测试用例、测试计划、QA 程序
   - ❌ 实现细节（框架、API、算法）

   **✅ 要求的模式** —— 这些用于测试需求质量：
   - ✅ “是否为 [场景] 定义/指定/记录了 [需求类型]？”
   - ✅ “[模糊术语] 是否通过具体的标准进行了量化/澄清？”
   - ✅ “[章节 A] 和 [章节 B] 之间的需求是否一致？”
   - ✅ “[需求] 是否可以被客观地衡量/验证？”
   - ✅ “需求中是否涵盖了 [边界情况/场景]？”
   - ✅ “规格说明是否定义了 [缺失方面]？”

6. **结构参考**：参照 `templates/checklist-template.md` 中的规范模板生成检查表，包括标题、元数据部分、类别标题和 ID 格式。如果模板不可用，请使用：H1 标题、目的/创建日期元数据行、包含 `- [ ] CHK### <需求项>` 行的 `##` 类别章节，ID 从 CHK001 开始全局递增。

7. **报告**：输出创建的检查表的完整路径、项目计数，并提醒用户每次运行都会创建一个新文件。总结：
   - 选择的关注领域
   - 深度级别
   - 执行者/时机
   - 整合的任何用户指定的明确必需项

**重要提示**：每次调用 `/speckit.checklist` 命令都会使用简短、描述性的名称创建检查表文件（除非文件已存在）。这允许：

- 拥有多个不同类型的检查表（例如 `ux.md`, `test.md`, `security.md`）
- 简单、好记的文件名，指示检查表的用途
- 在 `checklists/` 文件夹中轻松识别和导航

为了避免混乱，请使用描述性类型，并在完成后清理过时的检查表。

## 检查表类型示例与样本项

**UX 需求质量：** `ux.md`

样本项（测试需求，而非实现）：

- “视觉层级需求是否通过可衡量的标准进行了定义？ [清晰度, Spec §FR-1]”
- “UI 元素的数量和位置是否被明确指定？ [完整性, Spec §FR-1]”
- “交互状态需求（悬停、聚焦、激活）是否定义一致？ [一致性]”
- “是否为所有交互元素指定了无障碍需求？ [覆盖率, Gap]”
- “图片加载失败时是否定义了回退行为？ [边界情况, Gap]”
- “‘突出显示’是否可以被客观衡量？ [可衡量性, Spec §FR-4]”

**API 需求质量：** `api.md`

样本项：

- “是否为所有失败场景指定了错误响应格式？ [完整性]”
- “速率限制需求是否通过具体的阈值进行了量化？ [清晰度]”
- “所有端点的认证需求是否一致？ [一致性]”
- “是否为外部依赖项定义了重试/超时需求？ [覆盖率, Gap]”
- “需求中是否记录了版本控制策略？ [Gap]”

**性能需求质量：** `performance.md`

样本项：

- “性能需求是否通过具体的指标进行了量化？ [清晰度]”
- “是否为所有关键用户旅程定义了性能目标？ [覆盖率]”
- “是否指定了不同负载条件下的性能需求？ [完整性]”
- “性能需求是否可以被客观衡量？ [可衡量性]”
- “是否为高负载场景定义了降级需求？ [边界情况, Gap]”

**安全需求质量：** `security.md`

样本项：

- “是否为所有受保护资源指定了认证需求？ [覆盖率]”
- “是否为敏感信息定义了数据保护需求？ [完整性]”
- “是否记录了威胁模型，且需求与之对齐？ [可追溯性]”
- “安全需求是否与合规义务一致？ [一致性]”
- “是否定义了安全失败/漏洞响应需求？ [Gap, 异常流程]”

## 反面教材：不该做什么

**❌ 错误示例 —— 这些测试的是实现，而非需求：**

```markdown
- [ ] CHK001 - 验证落地页显示 3 个剧集卡片 [Spec §FR-001]
- [ ] CHK002 - 测试在桌面上悬停状态是否正常工作 [Spec §FR-003]
- [ ] CHK003 - 确认点击 Logo 会导航到首页 [Spec §FR-010]
- [ ] CHK004 - 检查相关剧集区域是否显示 3-5 个项目 [Spec §FR-005]
```

**✅ 正确示例 —— 这些测试的是需求质量：**

```markdown
- [ ] CHK001 - 精选剧集的数量和布局是否被明确指定？ [完整性, Spec §FR-001]
- [ ] CHK002 - 所有交互元素的悬停状态需求是否定义一致？ [一致性, Spec §FR-003]
- [ ] CHK003 - 对于所有可点击的品牌元素，导航需求是否清晰？ [清晰度, Spec §FR-010]
- [ ] CHK004 - 相关剧集的选择标准是否已记录？ [Gap, Spec §FR-005]
- [ ] CHK005 - 是否为异步剧集数据定义了加载状态需求？ [Gap]
- [ ] CHK006 - “视觉层级”需求是否可以被客观地衡量？ [可衡量性, Spec §FR-001]
```

**关键区别：**

- 错误做法：测试系统是否运行正确
- 正确做法：测试需求是否编写正确
- 错误做法：行为验证
- 正确做法：需求质量验证
- 错误做法：“它是否执行 X？”
- 正确做法：“X 是否被明确指定？”
