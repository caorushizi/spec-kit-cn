---
description: 根据自然语言的功能描述，创建或更新功能规格说明 (Feature Specification)。
handoffs: 
  - label: 构建技术计划
    agent: speckit.plan
    prompt: 为该规格说明创建计划。我构建使用的是...
  - label: 澄清规格说明需求
    agent: speckit.clarify
    prompt: 澄清规格说明需求
    send: true
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前，您**必须**考虑用户输入（如果不为空）。

## 纲要

用户在触发消息中 `/speckit.specify` 之后输入的文本**即为**功能描述。即使下方字面上出现了 `{ARGS}`，也请假设您在本次对话中始终可以使用该描述。除非用户提供的是空命令，否则不要要求用户重复。

根据该功能描述，执行以下操作：

1. **生成简明短名**（2-4 个词）用于分支：
   - 分析功能描述并提取最有意义的关键词
   - 创建一个 2-4 个词的短名，捕捉功能的本质
   - 尽可能使用“动词-名词”格式（例如 "add-user-auth", "fix-payment-bug"）
   - 保留技术术语和首字母缩略词（OAuth2, API, JWT 等）
   - 保持简练，但又要具有足够的描述性，以便一眼就能理解该功能
   - 示例：
     - "I want to add user authentication" → "user-auth"
     - "Implement OAuth2 integration for the API" → "oauth2-api-integration"
     - "Create a dashboard for analytics" → "analytics-dashboard"
     - "Fix payment processing timeout bug" → "fix-payment-timeout"

2. **在创建新分支之前检查是否存在现有分支**：

   a. 首先，获取所有远程分支以确保我们拥有最新信息：

      ```bash
      git fetch --all --prune
      ```

   b. 跨所有来源查找该短名的最高功能编号：
      - 远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - 规格说明目录：检查与 `specs/[0-9]+-<short-name>` 匹配的目录

   c. 确定下一个可用编号：
      - 从所有三个来源中提取所有编号
      - 找到最高编号 N
      - 将 N+1 作为新分支编号

   d. 使用计算出的编号和短名运行脚本 `{SCRIPT}`：
      - 将 `--number N+1` 和 `--short-name "your-short-name"` 以及功能描述一起传递
      - Bash 示例：`{SCRIPT} --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell 示例：`{SCRIPT} -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

   **重要提示**：
   - 检查所有三个来源（远程分支、本地分支、规格说明目录）以找到最高编号
   - 仅匹配具有精确短名模式的分支/目录
   - 如果未发现具有该短名的现有分支/目录，则从编号 1 开始
   - 每个功能只能运行此脚本一次
   - JSON 作为输出在终端中提供 —— 始终参考它来获取您要寻找的实际内容
   - JSON 输出将包含 BRANCH_NAME 和 SPEC_FILE 路径
   - 对于参数中包含单引号的情况（如 "I'm Groot"），请使用转义语法：例如 'I'\''m Groot'（或者尽可能使用双引号："I'm Groot"）。

3. 加载 `templates/spec-template.md` 以了解必需的章节。

4. 遵循以下执行流程：

    1. 解析输入中的用户描述
       如果为空：报错 ERROR "未提供功能描述"
    2. 从描述中提取关键概念
       识别：参与者 (actors)、动作 (actions)、数据 (data)、约束 (constraints)
    3. 对于不明确的方面：
       - 根据上下文和行业标准做出明智的推测
       - 仅在满足以下条件时才标记 [需澄清：具体问题]：
         - 该选择会显著影响功能范围或用户体验
         - 存在多种具有不同影响的合理解释
         - 不存在合理的默认设置
       - **限制：总共最多 3 个 [需澄清] 标记**
       - 按影响排序优先级：范围 > 安全/隐私 > 用户体验 > 技术细节
    4. 填充“用户场景与测试”章节
       如果没有明确的用户流程：报错 ERROR "无法确定用户场景"
    5. 生成功能需求
       每项需求必须是可测试的
       对于未指定的细节使用合理的默认值（在“假设”章节中记录假设）
    6. 定义成功标准
       创建可衡量的、技术无关的结果
       包括定量指标（时间、性能、容量）和定性度量（用户满意度、任务完成情况）
       每项标准必须可以在不知道实现细节的情况下进行验证
    7. 识别关键实体（如果涉及数据）
    8. 返回：成功 SUCCESS（规格说明已准备好进行规划）

5. 将规格说明写回 SPEC_FILE，使用模板结构，将占位符替换为从功能描述（参数）推导出的具体细节，同时保留章节顺序和标题。

6. **规格说明质量验证**：编写初始规格说明后，对照质量标准进行验证：

   a. **创建规格说明质量检查表**：在 `FEATURE_DIR/checklists/requirements.md` 处创建一个检查表文件，使用检查表模板结构，并包含以下验证项：

      ```markdown
      # 规格说明质量检查表：[功能名称]
      
      **目的**: 在进入规划阶段之前验证规格说明的完整性和质量
      **创建日期**: [日期]
      **功能**: [链接到 spec.md]
      
      ## 内容质量
      
      - [ ] 无实现细节（语言、框架、API）
      - [ ] 专注于用户价值和业务需求
      - [ ] 为非技术利益相关者编写
      - [ ] 所有必填章节均已完成
      
      ## 需求完整性
      
      - [ ] 不再留有 [需澄清] 标记
      - [ ] 需求是可测试且无歧义的
      - [ ] 成功标准是可衡量的
      - [ ] 成功标准是技术无关的（无实现细节）
      - [ ] 所有验收场景均已定义
      - [ ] 已识别边界情况
      - [ ] 范围界限明确
      - [ ] 已识别依赖关系和假设
      
      ## 功能就绪
      
      - [ ] 所有功能需求都有明确的验收标准
      - [ ] 用户场景涵盖了主要流程
      - [ ] 功能符合“成功标准”中定义的衡量结果
      - [ ] 规格说明中没有泄露实现细节
      
      ## 备注
      
      - 标记为未完成的项目需要在执行 `/speckit.clarify` 或 `/speckit.plan` 之前更新规格说明
      ```

   b. **运行验证检查**：对照每个检查项审查规格说明：
      - 对于每一项，确定其通过还是失败
      - 记录发现的具体问题（引用相关的规格说明章节）

   c. **处理验证结果**：

      - **如果所有项均通过**：将检查表标记为完成，并继续执行第 6 步

      - **如果项目失败（不包括 [需澄清]）**：
        1. 列出失败的项目和具体问题
        2. 更新规格说明以解决每个问题
        3. 重复验证直到所有项均通过（最多迭代 3 次）
        4. 如果迭代 3 次后仍失败，在检查表备注中记录剩余问题并警告用户

      - **如果仍留有 [需澄清] 标记**：
        1. 从规格说明中提取所有 [需澄清: ...] 标记
        2. **限制检查**：如果标记超过 3 个，仅保留 3 个最关键的（按范围/安全/UX 影响排序），对其余标记进行明智推测
        3. 对于每个需要的澄清（最多 3 个），按此格式向用户展示选项：

           ```markdown
           ## 问题 [N]: [主题] 
           
           **上下文**: [引用相关的规格说明章节] 
           
           **我们需要了解的内容**: [[需澄清] 标记中的具体问题]
           
           **建议的答案**: 
           
           | 选项 | 答案 | 影响 |
           |--------|--------|--------------|
           | A      | [第一个建议答案] | [这对该功能意味着什么] |
           | B      | [第二个建议答案] | [这对该功能意味着什么] |
           | C      | [第三个建议答案] | [这对该功能意味着什么] |
           | 自定义 | 提供您自己的答案 | [解释如何提供自定义输入] |
           
           **您的选择**: _[等待用户响应]_
           ```

        4. **关键 - 表格格式**：确保 Markdown 表格格式正确：
           - 使用一致的间距，对齐管道符
           - 每个单元格内容前后应有空格：使用 `| 内容 |` 而非 `|内容|`
           - 标题分隔符必须至少有 3 个破折号：`|--------|`
           - 测试表格在 Markdown 预览中能否正确渲染
        5. 对问题按顺序编号（Q1, Q2, Q3 - 总共最多 3 个）
        6. 在等待响应之前，将所有问题一起呈现
        7. 等待用户对所有问题做出选择（例如，“Q1: A, Q2: 自定义 - [详情], Q3: B”）
        8. 通过将每个 [需澄清] 标记替换为用户选择或提供的答案来更新规格说明
        9. 在所有澄清解决后重新运行验证

   d. **更新检查表**：在每次验证迭代后，更新检查表文件的当前通过/失败状态

7. 报告完成情况，包括分支名称、规格说明文件路径、检查表结果以及下一阶段（`/speckit.clarify` 或 `/speckit.plan`）的准备就绪情况。

**注意：** 脚本会在写入之前创建并切换到新分支，并初始化规格说明文件。

## 通用指南

- 关注用户需要**什么**以及**为什么**。
- 避免涉及**如何**实现（不要谈论技术栈、API、代码结构）。
- 为业务利益相关者编写，而非为开发人员编写。
- 不要创建嵌入在规格说明中的任何检查表。那将是一个单独的命令。

### 章节要求

- **必填章节**：每个功能都必须完成
- **可选章节**：仅在与功能相关时包含
- 当某个章节不适用时，将其完全移除（不要留作 "N/A"）

### 关于 AI 生成

从用户提示词创建此规格说明时：

1. **进行明智推测**：利用上下文、行业标准和常见模式来填补空白
2. **记录假设**：在“假设”章节中记录合理的默认值
3. **限制澄清**：最多 3 个 [需澄清] 标记 —— 仅用于以下关键决策：
   - 显著影响功能范围或用户体验
   - 存在多种具有不同影响的合理解释
   - 缺少任何合理的默认设置
4. **按影响排序优先级**：范围 > 安全/隐私 > 用户体验 > 技术细节
5. **像测试人员一样思考**：任何模糊的需求都应无法通过“可测试且无歧义”的检查项
6. **常见需要澄清的领域**（仅当不存在合理的默认值时）：
   - 功能范围和边界（包括/排除特定用例）
   - 用户类型和权限（如果可能存在多种冲突解释）
   - 安全/合规要求（当在法律/财务上具有重大意义时）

**合理默认值的示例**（不要询问这些）：

- 数据保留：该领域的行业标准做法
- 性能目标：除非另有说明，否则采用标准的 Web/移动端应用预期
- 错误处理：用户友好的消息并带有适当的回退方案
- 身份认证方式：Web 应用标准的基于会话的认证或 OAuth2
- 集成模式：除非另有说明，否则采用 RESTful API

### 成功标准指南

成功标准必须是：

1. **可衡量的**：包含具体指标（时间、百分比、计数、比率）
2. **技术无关的**：不提及框架、语言、数据库或工具
3. **以用户为中心的**：从用户/业务角度描述结果，而非系统内部
4. **可验证的**：可以在不知道实现细节的情况下进行测试/验证

**好的示例**：

- “用户可以在 3 分钟内完成结账”
- “系统支持 10,000 个并发用户”
- “95% 的搜索在 1 秒内返回结果”
- “任务完成率提高 40%”

**不好的示例**（关注实现细节）：

- “API 响应时间低于 200ms”（太技术化，改用“用户可以立即看到结果”）
- “数据库可以处理 1000 TPS”（实现细节，改用面向用户的指标）
- “React 组件高效渲染”（特定于框架）
- “Redis 缓存命中率高于 80%”（特定于技术）
